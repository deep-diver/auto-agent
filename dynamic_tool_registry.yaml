- tool_names:
  - search_web_with_serper
  code: "import requests\nimport json\nimport os\n\ndef search_web_with_serper(query:\
    \ str):\n    \"\"\"\n    Searches the web using the Serper API (google.serper.dev)\
    \ for a given query.\n\n    Args:\n        query (str): The search query.\n\n\
    \    Returns:\n        dict: A dictionary containing structured search results\
    \ including knowledge graph\n              information (if available) and a list\
    \ of organic search results, or an\n              error message if the search\
    \ fails.\n    \"\"\"\n    api_key = os.environ.get('SERPER_API_KEY')\n    if not\
    \ api_key:\n        return {\"error\": \"SERPER_API_KEY not found in environment\
    \ variables.\"}\n\n    url = \"https://google.serper.dev/search\"\n    payload\
    \ = json.dumps({\"q\": query})\n    headers = {\n        'X-API-KEY': api_key,\n\
    \        'Content-Type': 'application/json'\n    }\n\n    try:\n        response\
    \ = requests.request(\"POST\", url, headers=headers, data=payload, timeout=10)\n\
    \        response.raise_for_status()  # Raise an exception for HTTP errors (4xx\
    \ or 5xx)\n        data = response.json()\n\n        results = {\n           \
    \ \"query_executed\": query,\n            \"knowledge_graph_info\": None,\n  \
    \          \"organic_results\": []\n        }\n\n        if \"knowledgeGraph\"\
    \ in data and data[\"knowledgeGraph\"]:\n            kg = data[\"knowledgeGraph\"\
    ]\n            results[\"knowledge_graph_info\"] = {\n                \"title\"\
    : kg.get(\"title\"),\n                \"type\": kg.get(\"type\"),\n          \
    \      \"description\": kg.get(\"description\"),\n                \"description_source\"\
    : kg.get(\"descriptionSource\"),\n                \"description_link\": kg.get(\"\
    descriptionLink\"),\n                \"website\": kg.get(\"website\"),\n     \
    \           \"image_url\": kg.get(\"imageUrl\"),\n                \"attributes\"\
    : kg.get(\"attributes\")\n            }\n\n        if \"organic\" in data and\
    \ data[\"organic\"]:\n            for item in data[\"organic\"]:\n           \
    \     results[\"organic_results\"].append({\n                    \"title\": item.get(\"\
    title\"),\n                    \"link\": item.get(\"link\"),\n               \
    \     \"snippet\": item.get(\"snippet\"),\n                    \"position\": item.get(\"\
    position\")\n                })\n        \n        if not results[\"knowledge_graph_info\"\
    ] and not results[\"organic_results\"]:\n            return {\"message\": \"No\
    \ relevant information found for the query.\", \"query_executed\": query}\n\n\
    \        return results\n\n    except requests.exceptions.HTTPError as e:\n  \
    \      return {\"error\": f\"HTTP error occurred: {e}\", \"status_code\": e.response.status_code}\n\
    \    except requests.exceptions.RequestException as e:\n        return {\"error\"\
    : f\"Error calling Serper API: {e}\"}\n    except json.JSONDecodeError:\n    \
    \    return {\"error\": \"Failed to decode JSON response from Serper API.\"}\n\
    \    except Exception as e:\n        return {\"error\": f\"An unexpected error\
    \ occurred: {e}\"}\n"
- tool_names:
  - get_weather_for_location
  code: "import requests\nimport os\nimport json\n\ndef get_weather_for_location(location_query:\
    \ str) -> dict:\n    \"\"\"\n    Fetches current weather data for a specified\
    \ location using the OpenWeatherMap API.\n\n    Args:\n        location_query\
    \ (str): The city name and optionally country code (e.g., \"London\", \"London,UK\"\
    , \"Daejeon, South Korea\").\n\n    Returns:\n        dict: A dictionary containing\
    \ weather information (temperature, description, humidity, wind speed, etc.)\n\
    \              or an error message if the request fails.\n    \"\"\"\n    api_key\
    \ = os.environ.get('OPEN_WEATHER_API_KEY')\n    if not api_key:\n        return\
    \ {\"error\": \"OpenWeatherMap API key (OPEN_WEATHER_API_KEY) not found in environment.\"\
    }\n\n    base_url = 'https://api.openweathermap.org/data/2.5/weather'\n    params\
    \ = {\n        'q': location_query,\n        'appid': api_key,\n        'units':\
    \ 'metric'  # For Celsius\n    }\n\n    try:\n        response = requests.get(base_url,\
    \ params=params)\n        response.raise_for_status()  # Raises an HTTPError for\
    \ bad responses (4XX or 5XX)\n        data = response.json()\n\n        if data.get(\"\
    cod\") != 200 and data.get(\"message\"):\n            return {\"error\": f\"API\
    \ Error: {data.get('message')}\"}\n        \n        # Check for essential data\
    \ presence\n        if 'weather' not in data or not data['weather'] or 'main'\
    \ not in data or 'wind' not in data or 'name' not in data:\n            return\
    \ {\"error\": \"Incomplete weather data received from API.\"}\n\n        weather_description\
    \ = data['weather'][0]['description']\n        temperature = data['main']['temp']\n\
    \        feels_like = data['main']['feels_like']\n        humidity = data['main']['humidity']\n\
    \        wind_speed = data['wind']['speed']\n        city_name = data['name']\n\
    \        country = data.get('sys', {}).get('country')\n\n        return {\n  \
    \          \"location\": f\"{city_name}{',' + country if country else ''}\",\n\
    \            \"temperature_celsius\": temperature,\n            \"feels_like_celsius\"\
    : feels_like,\n            \"humidity_percent\": humidity,\n            \"weather_description\"\
    : weather_description,\n            \"wind_speed_mps\": wind_speed\n        }\n\
    \n    except requests.exceptions.HTTPError as http_err:\n        if response.status_code\
    \ == 401:\n            return {\"error\": \"Unauthorized. Invalid OpenWeatherMap\
    \ API key.\"}\n        elif response.status_code == 404:\n            return {\"\
    error\": f\"Location '{location_query}' not found.\"}\n        else:\n       \
    \     return {\"error\": f\"HTTP error occurred: {http_err}\"}\n    except requests.exceptions.RequestException\
    \ as req_err:\n        return {\"error\": f\"Request error occurred: {req_err}\"\
    }\n    except json.JSONDecodeError:\n        return {\"error\": \"Failed to decode\
    \ JSON response from OpenWeatherMap API.\"}\n    except KeyError as key_err:\n\
    \        return {\"error\": f\"Unexpected data format from OpenWeatherMap API.\
    \ Missing key: {key_err}\"}\n    except Exception as e:\n        return {\"error\"\
    : f\"An unexpected error occurred: {e}\"}\n"
- tool_names:
  - get_image_info_from_url
  code: "import requests\nimport os # Standard import, though not used for API keys\
    \ in this specific tool\n\ndef get_image_info_from_url(image_url: str):\n    \"\
    \"\"\n    Fetches basic information about an image from a URL, primarily its content\
    \ type,\n    to verify if it's an image.\n\n    Args:\n        image_url (str):\
    \ The URL of the image.\n\n    Returns:\n        dict: A dictionary containing:\n\
    \              - 'status' (str): 'success' or 'error'.\n              - 'url'\
    \ (str): The original image_url.\n              - 'content_type' (str, optional):\
    \ The detected content type if successful and identifiable.\n              - 'message'\
    \ (str, optional): An error message if status is 'error' or\n                \
    \                           if content type doesn't indicate an image.\n    \"\
    \"\"\n    try:\n        # Use HEAD request to get headers without downloading\
    \ the full image\n        # Set a timeout to prevent indefinite blocking\n   \
    \     headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64;\
    \ x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n\
    \        }\n        response = requests.head(image_url, allow_redirects=True,\
    \ timeout=10, headers=headers)\n        response.raise_for_status()  # Raise HTTPError\
    \ for bad responses (4xx or 5xx)\n\n        content_type = response.headers.get('Content-Type',\
    \ '').lower()\n\n        if content_type.startswith('image/'):\n            return\
    \ {\n                \"status\": \"success\",\n                \"url\": image_url,\n\
    \                \"content_type\": content_type\n            }\n        else:\n\
    \            # If Content-Type is not explicitly image/*, try a GET request for\
    \ a few bytes to check magic numbers\n            # This is a fallback for servers\
    \ that might not send accurate Content-Type on HEAD\n            try:\n      \
    \          response_get = requests.get(image_url, stream=True, allow_redirects=True,\
    \ timeout=10, headers=headers)\n                response_get.raise_for_status()\n\
    \                content_type_get = response_get.headers.get('Content-Type', '').lower()\n\
    \                if content_type_get.startswith('image/'):\n                 \
    \   return {\n                        \"status\": \"success\",\n             \
    \           \"url\": image_url,\n                        \"content_type\": content_type_get\n\
    \                    }\n                # Check magic bytes for common image types\
    \ if content_type is still not definitive\n                # Read first few bytes\n\
    \                magic_bytes = next(response_get.iter_content(chunk_size=12, decode_unicode=False),\
    \ b'')\n                if magic_bytes.startswith(b'\\xff\\xd8\\xff'): # JPEG\n\
    \                    identified_type = 'image/jpeg'\n                elif magic_bytes.startswith(b'\\\
    x89PNG\\r\\n\\x1a\\n'): # PNG\n                    identified_type = 'image/png'\n\
    \                elif magic_bytes.startswith(b'GIF87a') or magic_bytes.startswith(b'GIF89a'):\
    \ # GIF\n                    identified_type = 'image/gif'\n                elif\
    \ magic_bytes.startswith(b'BM'): # BMP\n                    identified_type =\
    \ 'image/bmp'\n                elif magic_bytes.startswith(b'RIFF') and magic_bytes[8:12]\
    \ == b'WEBP': # WebP\n                     identified_type = 'image/webp'\n  \
    \              else:\n                    identified_type = None\n           \
    \     \n                response_get.close() # Important to close the stream\n\
    \n                if identified_type:\n                    return {\n        \
    \                \"status\": \"success\",\n                        \"url\": image_url,\n\
    \                        \"content_type\": identified_type # Use identified type\
    \ over potentially vague header\n                    }\n                else:\n\
    \                    message = f\"URL does not appear to be a direct image link.\
    \ Content-Type from HEAD: {content_type if content_type else 'N/A'}. Content-Type\
    \ from GET: {content_type_get if content_type_get else 'N/A'}. Magic bytes did\
    \ not match known image types.\"\n                    return {\n             \
    \           \"status\": \"error\",\n                        \"url\": image_url,\n\
    \                        \"content_type\": content_type_get if content_type_get\
    \ else content_type,\n                        \"message\": message\n         \
    \           }\n            except requests.exceptions.RequestException as e_get:\n\
    \                 # If GET also fails or has issues, report based on original\
    \ HEAD or generic error\n                message = f\"Initial HEAD Content-Type:\
    \ {content_type if content_type else 'Not determined'}. Attempted GET failed:\
    \ {str(e_get)}.\"\n                if not content_type.startswith('image/'):\n\
    \                     message = f\"URL Content-Type ('{content_type}') does not\
    \ indicate an image. Also, a subsequent GET request failed: {str(e_get)}.\"\n\
    \                return {\n                    \"status\": \"error\",\n      \
    \              \"url\": image_url,\n                    \"content_type\": content_type\
    \ if content_type else None,\n                    \"message\": message\n     \
    \           }\n\n    except requests.exceptions.Timeout:\n        return {\n \
    \           \"status\": \"error\",\n            \"url\": image_url,\n        \
    \    \"message\": \"Error fetching image information: The request timed out.\"\
    \n        }\n    except requests.exceptions.RequestException as e:\n        return\
    \ {\n            \"status\": \"error\",\n            \"url\": image_url,\n   \
    \         \"message\": f\"Error fetching image information: {str(e)}\"\n     \
    \   }\n    except Exception as e: # Catch any other unexpected errors\n      \
    \  return {\n            \"status\": \"error\",\n            \"url\": image_url,\n\
    \            \"message\": f\"An unexpected error occurred: {str(e)}\"\n      \
    \  }\n"
- tool_names:
  - capture_screenshot
  code: "import os\nimport time\nfrom typing import Optional\n\n# Note: pyautogui\
    \ is not a standard library and needs to be installed.\n# e.g., pip install pyautogui\n\
    # It also has platform-specific dependencies for interacting with the display.\n\
    # On Linux, it might require `scrot` (sudo apt-get install scrot) for X11 systems,\n\
    # or integration with desktop environment tools for Wayland (e.g., gnome-screenshot,\
    \ grim).\n# It may not work in headless environments or with Wayland without specific\
    \ configurations.\n\ndef capture_screenshot(output_file_path: Optional[str] =\
    \ None) -> str:\n    \"\"\"\n    Captures a screenshot of the entire screen and\
    \ saves it to a file using pyautogui.\n\n    Args:\n        output_file_path (Optional[str]):\
    \ The desired path (including filename and extension, e.g., .png)\n          \
    \                                 to save the screenshot. If None, saves to 'screenshot_YYYYMMDD-HHMMSS.png'\n\
    \                                           in the current working directory,\
    \ then made absolute.\n\n    Returns:\n        str: A message indicating the absolute\
    \ path to the saved screenshot file if successful,\n             or an error message\
    \ string if failed.\n    \"\"\"\n    try:\n        import pyautogui\n    except\
    \ ImportError:\n        return \"Error: The 'pyautogui' library is not installed.\
    \ Please install it (e.g., 'pip install pyautogui'). This tool cannot function\
    \ without it.\"\n    except Exception as e: # Catch other potential issues during\
    \ pyautogui import, e.g. its own dependencies missing or display init issues\n\
    \        return f\"Error: Failed to import or initialize 'pyautogui'. It might\
    \ be due to a missing display or other system dependencies. Original error: {e}\"\
    \n\n    try:\n        final_path: str\n        if output_file_path:\n        \
    \    # Ensure the directory of the given path exists\n            abs_path = os.path.abspath(output_file_path)\n\
    \            directory = os.path.dirname(abs_path)\n            if directory:\
    \ # If directory is not empty (i.e., not just a filename in cwd)\n           \
    \     if not os.path.exists(directory):\n                    try:\n          \
    \              os.makedirs(directory, exist_ok=True)\n                    except\
    \ OSError as e:\n                        return f\"Error: Could not create directory\
    \ '{directory}'. {e}\"\n            final_path = abs_path\n        else:\n   \
    \         # Generate a default filename with a timestamp\n            timestamp\
    \ = time.strftime(\"%Y%m%d-%H%M%S\")\n            filename = f\"screenshot_{timestamp}.png\"\
    \n            # Save in the current working directory, then get absolute path\n\
    \            final_path = os.path.abspath(os.path.join(os.getcwd(), filename))\n\
    \n        # Take screenshot. This is the primary operation that might fail due\
    \ to environment.\n        screenshot_image = pyautogui.screenshot()\n       \
    \ screenshot_image.save(final_path)\n        return f\"Screenshot saved successfully\
    \ to {final_path}\"\n\n    except pyautogui.PyAutoGUIException as e: # Specific\
    \ exceptions from pyautogui during its operations\n        error_message = (\n\
    \            f\"Error during screenshot operation with pyautogui: {e}. \"\n  \
    \          \"This could be due to various reasons including: \"\n            \"\
    1. Missing OS-level dependencies for pyautogui (e.g., 'scrot' on Linux for X11,\
    \ or 'gnome-screenshot' or 'grim' for Wayland integration). \"\n            \"\
    2. Running in an environment where screen capture is not permitted or possible\
    \ (e.g., headless server, certain virtualized environments, Wayland without proper\
    \ portal/backend). \"\n            \"3. PyAutoGUI's FailSafeException if the mouse\
    \ cursor was moved to a screen corner (can be disabled via pyautogui.FAILSAFE\
    \ = False if necessary, but use with caution). \"\n            \"Please check\
    \ your environment and pyautogui documentation for troubleshooting.\"\n      \
    \  )\n        return error_message\n    except RuntimeError as e: # Often related\
    \ to display server issues not caught by PyAutoGUIException directly\n       \
    \ if \"Display not found\" in str(e) or \"No X11 DISPLAY variable\" in str(e)\
    \ or \\\n           \"XDG_RUNTIME_DIR\" in str(e).lower() or \"wayland\" in str(e).lower()\
    \ or \"Failed to connect to session bus\" in str(e) or \"X server\" in str(e):\n\
    \             return (f\"Runtime error likely related to display server: {e}.\
    \ \"\n                     \"PyAutoGUI requires a graphical environment. Ensure\
    \ it's available and configured \"\n                     \"(e.g., X11 display\
    \ variable set, or running in a desktop session). \"\n                     \"\
    This tool may not work in headless environments or some Wayland configurations\
    \ without specific setup.\")\n        return f\"Runtime error during screenshot:\
    \ {e}\"\n    except Exception as e:\n        # Catch any other general errors\
    \ during screenshot capture or file saving\n        return f\"An unexpected error\
    \ occurred while capturing or saving the screenshot: {e}\""
- tool_names:
  - launch_application
  code: "import subprocess\nimport platform\n\ndef launch_application(application_name:\
    \ str) -> str:\n    \"\"\"\n    Attempts to launch the specified application in\
    \ a non-blocking way.\n\n    Args:\n        application_name (str):\n        \
    \    - On Windows: The executable name (e.g., \"msedge.exe\", \"notepad.exe\"\
    ) \n                          or a name known to the 'start' command (e.g., \"\
    msedge\").\n                          Can also be a path to an executable.\n \
    \           - On macOS: The application name as known to \"open -a\" \n      \
    \                  (e.g., \"Safari\", \"Microsoft Edge\", \"TextEdit\").\n   \
    \         - On Linux: The command name of the application \n                 \
    \       (e.g., \"firefox\", \"gedit\", \"microsoft-edge\"). \n               \
    \         The application must be in the system's PATH.\n\n    Returns:\n    \
    \    str: A message indicating the outcome of the launch attempt.\n    \"\"\"\n\
    \    system = platform.system()\n    \n    try:\n        if system == \"Windows\"\
    :\n            # Use 'cmd /c start \"\" program_or_path' to launch applications.\n\
    \            # The empty string \"\" is a placeholder for the title for the 'start'\
    \ command.\n            # This allows 'start' to correctly handle paths with spaces\
    \ in 'application_name'.\n            subprocess.Popen([\"cmd\", \"/c\", \"start\"\
    , \"\", application_name], shell=False)\n            return f\"Attempting to launch\
    \ '{application_name}' on Windows.\"\n\n        elif system == \"Darwin\": # macOS\n\
    \            cmd_list = [\"open\", \"-a\", application_name]\n            subprocess.Popen(cmd_list)\n\
    \            return f\"Attempting to launch '{application_name}' on macOS.\"\n\
    \n        elif system == \"Linux\":\n            # Assumes application_name is\
    \ an executable in PATH.\n            # If application_name were to include arguments,\
    \ shlex.split() would be needed.\n            # For a single command name (which\
    \ might contain spaces if the path itself has spaces\n            # and it's correctly\
    \ referenced or symlinked), [application_name] is correct.\n            cmd_list\
    \ = [application_name]\n            subprocess.Popen(cmd_list)\n            return\
    \ f\"Attempting to launch '{application_name}' on Linux.\"\n        else:\n  \
    \          return f\"Error: Unsupported operating system: {system}.\"\n\n    except\
    \ FileNotFoundError:\n        # This error is raised if 'cmd' (Windows), 'open'\
    \ (macOS), or the 'application_name' (Linux) isn't found in PATH.\n        return\
    \ f\"Error: Command or application executable not found. Ensure it's installed\
    \ and in system PATH. Application specified: '{application_name}'.\"\n    except\
    \ Exception as e:\n        return f\"Error launching application '{application_name}':\
    \ {str(e)}\"\n"
- tool_names:
  - wait_for_seconds
  code: "import time\nimport os\n\ndef wait_for_seconds(seconds: float) -> str:\n\
    \    \"\"\"\n    Pauses the execution for a specified number of seconds.\n\n \
    \   Args:\n        seconds (float): The number of seconds to wait. Can be a fraction.\n\
    \n    Returns:\n        str: A message indicating the wait is complete or an error\
    \ message.\n    \"\"\"\n    if not isinstance(seconds, (int, float)):\n      \
    \  return \"Error: 'seconds' argument must be a number (integer or float).\"\n\
    \    if seconds < 0:\n        return \"Error: 'seconds' argument must be non-negative.\"\
    \n    \n    try:\n        time.sleep(seconds)\n        return f\"Successfully\
    \ waited for {seconds} second(s).\"\n    except Exception as e:\n        return\
    \ f\"An error occurred while waiting: {str(e)}\""
- tool_names:
  - fetch_webpage_content
  code: "import requests\nimport os\n\ndef fetch_webpage_content(url: str) -> str:\n\
    \    \"\"\"\n    Fetches the HTML content of a given URL.\n\n    Args:\n     \
    \   url: The URL of the webpage to fetch.\n\n    Returns:\n        The HTML content\
    \ as a string, or an error message if fetching fails.\n    \"\"\"\n    if not\
    \ url.startswith('http://') and not url.startswith('https://'):\n        return\
    \ \"Error: Invalid URL. URL must start with 'http://' or 'https://'.\"\n    try:\n\
    \        headers = {\n            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0;\
    \ Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',\n\
    \            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',\n\
    \            'Accept-Language': 'en-US,en;q=0.5',\n            'DNT': '1', # Do\
    \ Not Track Request Header\n            'Upgrade-Insecure-Requests': '1'\n   \
    \     }\n        response = requests.get(url, headers=headers, timeout=15) # Increased\
    \ timeout\n        response.raise_for_status()  # Raise an exception for HTTP\
    \ errors (4xx or 5xx)\n        return response.text\n    except requests.exceptions.HTTPError\
    \ as http_err:\n        return f\"HTTP error occurred: {http_err} - Status Code:\
    \ {response.status_code if 'response' in locals() else 'N/A'}\"\n    except requests.exceptions.ConnectionError\
    \ as conn_err:\n        return f\"Connection error occurred: {conn_err}\"\n  \
    \  except requests.exceptions.Timeout as timeout_err:\n        return f\"Timeout\
    \ error occurred while trying to fetch {url}: {timeout_err}\"\n    except requests.exceptions.RequestException\
    \ as req_err:\n        return f\"An error occurred during the request for {url}:\
    \ {req_err}\"\n    except Exception as e:\n        return f\"An unexpected error\
    \ occurred while fetching {url}: {e}\""
- tool_names:
  - extract_items_with_date_from_html
  code: "import os\nfrom bs4 import BeautifulSoup\nfrom datetime import datetime\n\
    \ndef extract_items_with_date_from_html(html_content: str, target_date_str: str,\
    \ item_selector: str, title_selector_within_item: str, date_selector_within_item:\
    \ str, link_selector_within_item: str = None, date_attribute: str = None, date_format_in_html_text:\
    \ str = None):\n    \"\"\"\n    Extracts items with titles, dates, and optional\
    \ links from HTML content, \n    filtering them by a target date. \n\n    Args:\n\
    \        html_content (str): The HTML content as a string.\n        target_date_str\
    \ (str): The target date string to filter by (e.g., \"YYYY-MM-DD\" or \"YYYY/MM/DD\"\
    ).\n        item_selector (str): CSS selector for the container of each item (e.g.,\
    \ 'article.paper').\n        title_selector_within_item (str): CSS selector for\
    \ the title element, relative to the item container.\n        date_selector_within_item\
    \ (str): CSS selector for the date element, relative to the item container.\n\
    \        link_selector_within_item (str, optional): CSS selector for the link\
    \ element (e.g., an <a> tag),\n                                              \
    \   relative to the item container. Defaults to None.\n        date_attribute\
    \ (str, optional): If the date is in an attribute of the date_element (e.g., 'datetime'\
    \ \n                                      for <time datetime=\"...\">). If None,\
    \ tool tries to parse text content.\n                                      Defaults\
    \ to None.\n        date_format_in_html_text (str, optional): strptime format\
    \ string if parsing date from text content of \n                             \
    \                   the date_element. Required if date_attribute is None and date\
    \ is not ISO.\n                                                Defaults to None.\n\
    \n    Returns:\n        list: A list of dictionaries, where each dictionary contains\
    \ 'title', 'extracted_date', \n              and 'link' (if found) for items matching\
    \ the target date. \n              Returns an empty list if no items are found\
    \ or an error occurs.\n    \"\"\"\n    results = []\n    try:\n        # Parse\
    \ the target date string\n        target_date_obj = None\n        for fmt in ('%Y-%m-%d',\
    \ '%Y/%m/%d'):\n            try:\n                target_date_obj = datetime.strptime(target_date_str,\
    \ fmt).date()\n                break\n            except ValueError:\n       \
    \         continue\n        if not target_date_obj:\n            return {\"error\"\
    : f\"Invalid target_date_str format: {target_date_str}. Use YYYY-MM-DD or YYYY/MM/DD.\"\
    }\n\n        soup = BeautifulSoup(html_content, 'html.parser')\n        items\
    \ = soup.select(item_selector)\n\n        if not items:\n            return []\
    \ # No items found matching the item_selector\n\n        for item in items:\n\
    \            title_element = item.select_one(title_selector_within_item)\n   \
    \         title = title_element.get_text(strip=True) if title_element else None\n\
    \n            date_element = item.select_one(date_selector_within_item)\n    \
    \        if not date_element or not title:\n                continue\n\n     \
    \       extracted_date_str = None\n            item_date_obj = None\n\n      \
    \      if date_attribute:\n                extracted_date_str = date_element.get(date_attribute)\n\
    \                if extracted_date_str:\n                    # Handle ISO 8601\
    \ format (e.g., \"2023-05-13T10:00:00Z\")\n                    try:\n        \
    \                if 'T' in extracted_date_str:\n                             #\
    \ Take only the date part before 'T'\n                            date_part =\
    \ extracted_date_str.split('T')[0]\n                            item_date_obj\
    \ = datetime.strptime(date_part, '%Y-%m-%d').date()\n                        else:\
    \ # Assume it's already YYYY-MM-DD\n                            item_date_obj\
    \ = datetime.strptime(extracted_date_str, '%Y-%m-%d').date()\n               \
    \     except ValueError:\n                        # Could try other ISO parsing\
    \ if needed, but keeping it simple\n                        pass # item_date_obj\
    \ remains None\n            elif date_format_in_html_text:\n                extracted_date_str\
    \ = date_element.get_text(strip=True)\n                try:\n                \
    \    item_date_obj = datetime.strptime(extracted_date_str, date_format_in_html_text).date()\n\
    \                except ValueError:\n                    pass # item_date_obj\
    \ remains None\n            else: # Try to parse common date text if no attribute\
    \ and no format given (basic attempt)\n                extracted_date_str = date_element.get_text(strip=True)\n\
    \                try: # Attempt YYYY-MM-DD from text directly\n              \
    \      item_date_obj = datetime.strptime(extracted_date_str, '%Y-%m-%d').date()\n\
    \                except ValueError:\n                    pass # Add more common\
    \ format guesses here if necessary\n            \n            if item_date_obj\
    \ and item_date_obj == target_date_obj:\n                link = None\n       \
    \         if link_selector_within_item:\n                    link_element = item.select_one(link_selector_within_item)\n\
    \                    if link_element and link_element.name == 'a' and 'href' in\
    \ link_element.attrs:\n                        link = link_element['href']\n \
    \                   elif link_element: # If not an <a> tag or no href, capture\
    \ text as fallback or leave None\n                        pass # link remains\
    \ None\n                \n                results.append({\n                 \
    \   \"title\": title,\n                    \"extracted_date\": item_date_obj.strftime('%Y-%m-%d'),\n\
    \                    \"link\": link\n                })\n        \n        return\
    \ results\n\n    except Exception as e:\n        # Log error e for debugging if\
    \ necessary\n        return {\"error\": f\"An error occurred during HTML processing:\
    \ {str(e)}\"}\n"
- tool_names:
  - download_and_extract_text_from_pdf
  code: "import requests\nimport io\nfrom PyPDF2 import PdfReader # Ensure PyPDF2\
    \ is installed (pip install PyPDF2)\n\ndef download_and_extract_text_from_pdf(pdf_url:\
    \ str) -> str:\n    \"\"\"\n    Downloads a PDF from a given URL and extracts\
    \ text content from it.\n\n    Args:\n        pdf_url: The URL of the PDF file.\n\
    \n    Returns:\n        The extracted text content from the PDF.\n        Returns\
    \ an error message string if any issue occurs (e.g., download error, \n      \
    \  not a PDF, encrypted PDF, no text extractable).\n    \"\"\"\n    if not isinstance(pdf_url,\
    \ str) or not pdf_url.startswith(('http://', 'https://')):\n        return \"\
    Error: Invalid URL format. URL must be a string starting with http:// or https://.\"\
    \n\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64;\
    \ x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'\n\
    \    }\n\n    try:\n        response = requests.get(pdf_url, headers=headers,\
    \ timeout=30, stream=False) # stream=False to use response.content\n        response.raise_for_status()\
    \  # Raise an exception for HTTP errors (4xx or 5xx)\n\n        content_type =\
    \ response.headers.get('Content-Type', '').lower()\n        if 'application/pdf'\
    \ not in content_type:\n            return f\"Error: URL does not point to a PDF\
    \ file. Content-Type: {content_type}. URL: {pdf_url}\"\n\n        pdf_file_bytes\
    \ = response.content\n        if not pdf_file_bytes:\n             return f\"\
    Error: Downloaded PDF from {pdf_url} is empty.\"\n\n        pdf_file_obj = io.BytesIO(pdf_file_bytes)\n\
    \        \n        try:\n            pdf_reader = PdfReader(pdf_file_obj)\n  \
    \      except Exception as e:\n            # PyPDF2 can raise various errors for\
    \ corrupted/encrypted/unsupported PDFs\n            if 'encrypted' in str(e).lower()\
    \ or 'password' in str(e).lower():\n                 return f\"Error: PDF from\
    \ {pdf_url} is encrypted or password-protected and cannot be opened. Original\
    \ error: {str(e)}\"\n            return f\"Error: Could not read PDF structure\
    \ from {pdf_url}. The file might be corrupted or not a standard PDF. Original\
    \ error: {str(e)}\"\n\n        if pdf_reader.is_encrypted:\n            # Some\
    \ PDFs are marked as encrypted but might be readable with a blank password (default\
    \ for PyPDF2)\n            # If PdfReader opened it, it means it was either not\
    \ encrypted or decrypted with blank password.\n            # If it's truly encrypted\
    \ with a non-blank password, PdfReader(pdf_file_obj) would have likely failed.\n\
    \            # This is a fallback check in case it opened but extract_text fails\
    \ due to encryption issues.\n            pass # Proceed to try extracting text\n\
    \n        text = \"\"\n        for page_num in range(len(pdf_reader.pages)):\n\
    \            try:\n                page = pdf_reader.pages[page_num]\n       \
    \         page_text = page.extract_text()\n                if page_text:\n   \
    \                 text += page_text + \"\\n\"\n            except Exception as\
    \ e:\n                # Log page-specific extraction error if needed, but continue\
    \ for other pages\n                text += f\"[Error extracting text from page\
    \ {page_num + 1}: {str(e)}]\\n\"\n        \n        if not text.strip():\n   \
    \         return f\"Error: No text could be extracted from the PDF at {pdf_url}.\
    \ The PDF might primarily contain images of text, have a non-standard text encoding,\
    \ or be too complex.\"\n\n        return text.strip()\n\n    except requests.exceptions.Timeout:\n\
    \        return f\"Error: Request timed out while trying to download PDF from\
    \ {pdf_url}.\"\n    except requests.exceptions.HTTPError as e:\n        return\
    \ f\"Error: HTTP error {e.response.status_code} while downloading PDF from {pdf_url}.\
    \ Message: {e.response.text[:200]}\"\n    except requests.exceptions.RequestException\
    \ as e:\n        return f\"Error: Could not download PDF from URL {pdf_url}. {str(e)}\"\
    \n    except Exception as e:\n        return f\"Error: An unexpected error occurred\
    \ while processing the PDF from {pdf_url}. {str(e)}\""
- tool_names:
  - open_url_in_default_browser
  code: "import webbrowser\nimport platform\nimport subprocess\n\ndef open_url_in_default_browser(url:\
    \ str) -> str:\n    \"\"\"\n    Opens the given URL in the default web browser.\n\
    \n    Args:\n        url (str): The URL to open. It should be a fully qualified\
    \ URL,\n                   including the scheme (e.g., \"http://example.com\"\
    \ or \"https://example.com\").\n\n    Returns:\n        str: A message indicating\
    \ success or failure.\n    \"\"\"\n    if not isinstance(url, str):\n        return\
    \ \"Error: URL must be a string.\"\n    if not (url.startswith(\"http://\") or\
    \ url.startswith(\"https://\")):\n        return \"Error: URL must be fully qualified\
    \ and start with 'http://' or 'https://'.\"\n\n    try:\n        # Attempt to\
    \ open in a new tab if possible, and bring the browser to the front.\n       \
    \ if webbrowser.open(url, new=2, autoraise=True):\n            return f\"Successfully\
    \ launched default web browser to open URL: {url}\"\n        else:\n         \
    \   # webbrowser.open returning False can mean no browser was found or an issue\
    \ occurred.\n            # On Linux, xdg-open is often more reliable if webbrowser.get()\
    \ fails or if no\n            # 'BROWSER' env var is set and Python's internal\
    \ list is insufficient.\n            system_name = platform.system()\n       \
    \     if system_name == \"Linux\":\n                try:\n                   \
    \ # Using subprocess.run to attempt opening with xdg-open\n                  \
    \  # check=True will raise CalledProcessError if xdg-open returns non-zero.\n\
    \                    subprocess.run(['xdg-open', url], check=True, stdout=subprocess.DEVNULL,\
    \ stderr=subprocess.DEVNULL)\n                    return f\"Successfully launched\
    \ default web browser (using xdg-open) to open URL: {url}\"\n                except\
    \ FileNotFoundError:\n                    return \"Error: Could not open URL.\
    \ 'xdg-open' command not found. Please ensure it is installed and in your PATH.\"\
    \n                except subprocess.CalledProcessError as e_xdg:\n           \
    \         return f\"Error: 'xdg-open' failed to open URL {url}. Exit code: {e_xdg.returncode}.\
    \ Error: {e_xdg.stderr if e_xdg.stderr else 'N/A'}\"\n                except Exception\
    \ as e_cmd: # Catch other potential errors from subprocess.run\n             \
    \       return f\"Error: An unexpected error occurred while trying to use xdg-open\
    \ for URL {url}: {e_cmd}\"\n            \n            # If not Linux or if the\
    \ Linux specific xdg-open attempt failed within this 'else' block.\n         \
    \   return f\"Error: Could not open URL {url}. webbrowser.open() returned False.\
    \ This might mean no default browser is configured or an error occurred.\"\n\n\
    \    except webbrowser.Error as e_wb:\n        return f\"Error: A problem occurred\
    \ with the webbrowser module while trying to open URL {url}: {e_wb}\"\n    except\
    \ Exception as e_general:\n        # Catch any other unexpected exceptions\n \
    \       return f\"Error: An unexpected error occurred while trying to open URL\
    \ {url}: {e_general}\"\n"
